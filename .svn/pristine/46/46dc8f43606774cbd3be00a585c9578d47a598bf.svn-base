{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "try:\n",
    "    import Image\n",
    "except ImportError:\n",
    "    from PIL import Image\n",
    "import cv2\n",
    "import numpy as np\n",
    "import pytesseract\n",
    "from matplotlib import pyplot as plt\n",
    "import math\n",
    "from math import radians, degrees\n",
    "from pdftabextract import imgproc\n",
    "from pdftabextract.common import ROTATION, SKEW_X, SKEW_Y, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL\n",
    "from tabledetect import detectTable, cutImage,roiToCell\n",
    "import pandas as pd\n",
    "import json\n",
    "from BaiduAipOcr import BaiduAipOcr\n",
    "tempout = \"temp/\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def getGridabc(img, x_segmentation, y_segmentation):\n",
    "    h, w = img.shape\n",
    "\n",
    "    rows = []\n",
    "    colums = []\n",
    "    # abc 定制\n",
    "\n",
    "    for i, (startx, endx) in enumerate(x_segmentation):\n",
    "        if i+1 < len(x_segmentation):\n",
    "            next_x =  x_segmentation[i+1][0]\n",
    "        else:\n",
    "            next_x = w-1\n",
    "            \n",
    "        colums.append(endx+round((next_x -endx)/2))\n",
    "\n",
    "        #cv2.line(img, (self.rows[i], 0), (self.rows[i], h), green)\n",
    "\n",
    "    for i, (starty, endy) in enumerate(y_segmentation):\n",
    "\n",
    "        if i+1 < len(y_segmentation):\n",
    "            next_y =  y_segmentation[i+1][0]\n",
    "        else:\n",
    "            next_y = h-1\n",
    "            \n",
    "\n",
    "        rows.append(endy+round((next_y-endy)/2))\n",
    "        #cv2.line(img, (0, self.colums[i]), (w, self.colums[i]), green)\n",
    "    colums[-1]= w-1\n",
    "    rows[-1] = h-1\n",
    "        #cv2.imwrite(\"gride.jpg\", img)\n",
    "\n",
    "    return rows, colums\n",
    "\n",
    "# 根据mask 找出印章，覆盖dstimg 印章区域\n",
    "def removeStamp(dstimg,maskimg=None,pointsTheshold=100,areathreshold = 1000.0,color = (255,255,255),debug=False):\n",
    "    dstimgT = dstimg.copy()\n",
    "    #if maskimg is None:\n",
    "        \n",
    "    imgrayT=cv2.Canny(dstimg,100,200,3)#Canny边缘检测，参数可更改\n",
    "    ret,maskimgT = cv2.threshold(imgrayT,10,255,cv2.THRESH_BINARY)  \n",
    "        \n",
    "    image, contours, hierarchy = cv2.findContours(maskimgT,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)#contours为轮廓集，可以计算轮廓的长度、面积等  \n",
    "    #emptyImageTT = np.zeros(maskimgT.shape, np.uint8)\n",
    "    #print(len(contours))\n",
    "    #print(3)\n",
    "    #plt.gcf().set_size_inches(60.0,40.0)\n",
    "    #plt.subplot(2,1,1),plt.imshow(imgrayT,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(maskimgT,'gray')\n",
    "\n",
    "\n",
    "    #plt.show() \n",
    "    for cnt in contours:  \n",
    "        #print(len(cnt))\n",
    "        if len(cnt) > pointsTheshold:  \n",
    "            S1=cv2.contourArea(cnt)  \n",
    "            ell=cv2.fitEllipse(cnt)  \n",
    "            S2 =math.pi*ell[1][0]*ell[1][1] \n",
    "            #print(S2)\n",
    "            if S1 > areathreshold and (S1/S2)>0.005 :#面积比例，可以更改，根据数据集。。。  \n",
    "                print(S1,S2,ell)\n",
    "                #cv2.drawContours(emptyImageTT, cnt, -1, (255, 255, 255), 2)\n",
    "                cv2.ellipse(dstimgT, ell,color, 15)\n",
    "                cv2.ellipse(dstimgT, ell,color, cv2.FILLED)\n",
    "\n",
    "                \n",
    "    return dstimgT\n",
    "def imgtotable(img,rows,colums,debug=False):\n",
    "    ocrclient = BaiduAipOcr()\n",
    "    tablelist = [[\"\" for col in range(0,len(colums))] for row in range(0,len(rows))]\n",
    "    #print(tablelist)\n",
    "    for row, y in enumerate(rows):\n",
    "        print(\"行{}：\".format(row),end=\" \")\n",
    "        for colum,x in enumerate(colums):\n",
    "            if row == 0:\n",
    "                y1=0\n",
    "            else:\n",
    "                y1=rows[row-1]\n",
    "            if colum == 0:\n",
    "                x1=0\n",
    "            else:\n",
    "                x1=colums[colum-1]\n",
    "            x2=x\n",
    "            y2=y\n",
    "            roiimg = img[y1:y2,\n",
    "                  x1:x2]\n",
    "\n",
    "            try:\n",
    "                print(\"列{}：\".format(colum),end=\" \")\n",
    "                if debug:\n",
    "                    text=\"err\"\n",
    "                    cv2.imwrite(\"testimage/{}{}.jpg\".format(row,colum),roiimg)\n",
    "                else:\n",
    "                    text = ocrclient.image_to_string(roiimg)\n",
    "            except Exception as e:\n",
    "                print(e)\n",
    "                print(\"RECT:[{}:{},{}:{}]\".format(\n",
    "                    y1, y2, x1, x2))\n",
    "                text = \"error\"\n",
    "            #print(row,colum)\n",
    "            tablelist[row][colum] = text\n",
    "        print(\"\")\n",
    "    return tablelist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "def ocrimgtoexcel(filename,path,debug=False ):\n",
    "    print('1：读取文件{}'.format(filename))\n",
    "    filepath=os.path.join(path,filename)\n",
    "    iproc_obj = imgproc.ImageProc(filepath)\n",
    "    print(iproc_obj.input_img.shape)\n",
    "    print('2：检测水平线和角度')\n",
    "    sum = 0.0\n",
    "    number = 0\n",
    "    lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                         hough_rho_res=1,\n",
    "                                         hough_theta_res=np.pi/500,\n",
    "                                         hough_votes_thresh=350)\n",
    "\n",
    "\n",
    "    img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "    theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "    angle = degrees(theta_rotate[1])\n",
    "    print(\"-----方向{} 校正角度 {}\".format(theta_rotate[0],angle))\n",
    "    #theta_rotateV = iproc_obj.find_rotation_or_skew(only_direction=DIRECTION_VERTICAL)\n",
    "    #print(\"-----垂直校正角度 {}\".format(theta_rotate))\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(img_lines,\"gray\")\n",
    "        plt.show()\n",
    "    print('3：水平校正')\n",
    "    rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,-angle)\n",
    "    print(rotate_image.shape)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(rotate_image,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "    print('4：检测表格上下横线')\n",
    "    thresh_img = cv2.adaptiveThreshold(\n",
    "        ~rotate_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "    h_img = thresh_img.copy()\n",
    "    scale = 10\n",
    "    h_size = int(h_img.shape[1]/scale)\n",
    "\n",
    "    h_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "    dashed_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "    h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1) # 虚线转为实线\n",
    "    h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1) #腐蚀掉非水平的对象\n",
    "    #h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(90,50)\n",
    "        plt.subplot(1,1,1),plt.imshow(h_erode_img,'gray')\n",
    "        #plt.subplot(1,1,2),plt.imshow(h_erode_img,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    \n",
    "    print('5：计算表格上下线坐标')\n",
    "    dtable = detectTable(rotate_image)\n",
    "    x_count,x_segmentation = dtable.verticalShadow(h_erode_img,200)\n",
    "    y_count,y_segmentation = dtable.horizontalShadow(h_erode_img,300)\n",
    "\n",
    "    #print(len(x_segmentation))\n",
    "    #print(len(y_segmentation))\n",
    "    if debug:\n",
    "        emptyImagev, emptyImageh=dtable.getShadowimg(h_erode_img,x_count,y_count)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(emptyImageh,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    rows,colums=dtable.getGrid(h_erode_img,x_segmentation,y_segmentation)\n",
    "    x1= 10\n",
    "    y1= rows[0]+5    # 切掉周边，避免干扰\n",
    "    x2= rotate_image.shape[1]-10\n",
    "    y2= rows[-1]-5\n",
    "\n",
    "    print(\"上坐标线y1={},下坐标线y2={}\".format(y1,y2))\n",
    "    rotate_image = removeStamp(rotate_image)  #去掉印章\n",
    "    tablerect = rotate_image[y1:y2, x1:x2] #获取表格部分\n",
    "    if debug:\n",
    "        print(\"共{}行{}列\".format(len(rows),len(colums)))\n",
    "        print(x_segmentation,y_segmentation)\n",
    "        print(rows,colums)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "\n",
    "        plt.show()\n",
    "          \n",
    "    print('6：计算行和列分割线，水平和垂直投影')\n",
    "    dt = detectTable(tablerect)\n",
    "    gaussianimg = cv2.GaussianBlur(tablerect,(3,3),0)\n",
    "    sobel = cv2.Sobel(gaussianimg, cv2.CV_8U, 1, 0, ksize = 3)\n",
    "    ret, binary = cv2.threshold(sobel, 20, 255, cv2.THRESH_OTSU+cv2.THRESH_BINARY)\n",
    "    text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (17, 11))  # 形态学因子\n",
    "    text_structureH = cv2.getStructuringElement(\n",
    "        cv2.MORPH_CROSS, (17, 1)) \n",
    "    text_structureX = cv2.getStructuringElement(\n",
    "        cv2.MORPH_CROSS, (5, 5))\n",
    "    h_dilate_imgT = cv2.dilate(binary, text_structure, 1)\n",
    "    h_erode_img = cv2.erode(h_dilate_imgT, text_structure2, 1)\n",
    "    h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "\n",
    "\n",
    "    h_threshold = int(tablerect.shape[0]/10)\n",
    "    v_threshold = int(tablerect.shape[1]/15)\n",
    "    print(h_threshold,v_threshold)\n",
    "    x_count,x_segmentation = dt.verticalShadow(h_erode_img,h_threshold)\n",
    "    y_count,y_segmentation = dt.horizontalShadow(h_dilate_img,v_threshold)\n",
    "\n",
    "    print(len(x_segmentation))\n",
    "    print(len(y_segmentation))\n",
    "    if debug:\n",
    "        emptyImagev, emptyImageh=dt.getShadowimg(tablerect,x_count,y_count)\n",
    "        plt.gcf().set_size_inches(40.0,40.0)\n",
    "        plt.subplot(2,2,1),plt.imshow(h_dilate_imgT,'gray')\n",
    "        plt.subplot(2,2,2),plt.imshow(h_dilate_img,'gray')\n",
    "        plt.subplot(2,2,3),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(2,2,4),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "        plt.show()\n",
    "    print('7：得到cell对应图片')\n",
    "    rows,colums=getGridabc(tablerect,x_segmentation,y_segmentation)\n",
    "    print(\"表格共{}行{}\".format(len(rows),len(colums)))\n",
    "    if debug:\n",
    "        #print(x_segmentation)\n",
    "        #print(y_segmentation)\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        h,w=tablerect.shape\n",
    "        emptyImage1 = tablerect.copy()\n",
    "        for x in colums:\n",
    "            cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "        for y in rows:\n",
    "\n",
    "            cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.imshow(emptyImage1,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "          \n",
    "    print('8：每个cell进行识别的tablelist') \n",
    "    \n",
    "    tablelist = imgtotable(tablerect,rows,colums,debug)\n",
    "    print('9：保存文件')       \n",
    "    savename,extension = os.path.splitext(filename)      \n",
    "    df=pd.DataFrame(tablelist)\n",
    "    tempoutpath=os.path.join(path,tempout)\n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "    writer = pd.ExcelWriter(savepath)\n",
    "    df.to_excel(writer, sheet_name=savename)\n",
    "    writer.save()\n",
    "    writer.close()\n",
    "    print('10：{}.jpg '.format(savename))\n",
    "    \n",
    "    return df\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/abc/'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        sheet_data = ocrimgtoexcel(file,fpath,debug=False)\n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "        sheet_data.to_excel(writer, sheet_name=fname)\n",
    "    writer.save()\n",
    "    writer.close()  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "path = 'j:/fgf/'\n",
    "filename=\"1.jpg\"\n",
    "ocrimgtoexcel(filename,path,debug=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "处理 j:/农业/ excel\n",
      "---- abc7416_页面_02.xlsx is start---\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'pd' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-1-2f96ed3c9e23>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m     13\u001b[0m         \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"---- {} is start---\"\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     14\u001b[0m         \u001b[0mfilepath\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mos\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpath\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfpathe\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mfile\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 15\u001b[1;33m         \u001b[0mdframe\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mread_excel\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfilepath\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msheet_name\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mfname\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     16\u001b[0m         \u001b[1;32mfor\u001b[0m \u001b[0mindex\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mrows\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mdframe\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0miterrows\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     17\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mindex\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'pd' is not defined"
     ]
    }
   ],
   "source": [
    "import os\n",
    "def formatnumber(t):\n",
    "    t= t.replace('.','')\n",
    "    t= t.replace(',','')\n",
    "    if(len(t)>2):\n",
    "        tt =''.join([t[:-2],'.',t[-2:]])\n",
    "    else:\n",
    "        tt =''.join([t,'.00'])\n",
    "    return tt\n",
    "fpathe = 'j:/农业/'\n",
    "print(\"处理 {} excel\".format(fpathe))\n",
    "\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.xlsx':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        filepath = os.path.join(fpathe,file)\n",
    "        dframe = pd.read_excel(filepath, sheet_name=fname)\n",
    "        for index,rows in dframe.iterrows():\n",
    "            if index == 0:\n",
    "                continue\n",
    "            dframe.iloc[index,2] = formatnumber(rows[2])\n",
    "\n",
    "            dframe.iloc[index,3] = formatnumber(rows[3])\n",
    "\n",
    "\n",
    "        dframe.to_excel(os.path.join(fpathe,fname+'t'+extension))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import os\n",
    "debug = True\n",
    "path = 'j:/abc/'\n",
    "filename=\"abc7416_页面_26.jpg\"\n",
    "\n",
    "print('1：读取文件')\n",
    "filepath=os.path.join(path,filename)\n",
    "iproc_obj = imgproc.ImageProc(filepath)\n",
    "print(iproc_obj.input_img.shape)\n",
    "print(iproc_obj.gray_img.shape)\n",
    "print('2：检测水平线和角度')\n",
    "sum = 0.0\n",
    "number = 0\n",
    "hough_rho_res=1\n",
    "hough_theta_res=np.pi/300\n",
    "hough_votes_thresh=150\n",
    "lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                     hough_rho_res=1,\n",
    "                                     hough_theta_res=np.pi/600,\n",
    "                                     hough_votes_thresh=500)\n",
    "\n",
    "\"\"\"\n",
    "imgrayT=cv2.Canny(iproc_obj.gray_img,50,250,3)#Canny边缘检测，参数可更改\n",
    "# detect lines with hough transform\n",
    "lines = cv2.HoughLines(imgrayT, hough_rho_res,\n",
    "                       hough_theta_res, hough_votes_thresh)\n",
    "\"\"\"\n",
    "img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "\n",
    "#theta_rotate = iproc_obj.find_rotation_or_skew()\n",
    "\n",
    "#theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "#angle = -degrees(theta_rotate[1])\n",
    "\n",
    "print(\"-----校正角度 {}\".format(angle))\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(img_lines,\"gray\")\n",
    "    plt.show()\n",
    "print('3：水平校正')\n",
    "\n",
    "rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,angle)\n",
    "print(rotate_image.shape)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(rotate_image,'gray')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tx=img_lines.shape\n",
    "print(tx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(degrees(0.00987357712749924))\n",
    "print(degrees(0.0062832077357430904))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('4：检测表格上下横线')\n",
    "thresh_img = cv2.adaptiveThreshold(\n",
    "    ~rotate_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "h_img = thresh_img.copy()\n",
    "scale = 10\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "h_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1)\n",
    "h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(90,50)\n",
    "    plt.subplot(2,1,1),plt.imshow(h_dilate_imgT,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(h_erode_img,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dt = detectTable(rotate_image)\n",
    "print('5：计算行和列分割线') \n",
    "x_count,x_segmentation = dt.verticalShadow(h_erode_img,200)\n",
    "y_count,y_segmentation = dt.horizontalShadow(h_erode_img,300)\n",
    "\n",
    "print(len(x_segmentation))\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    #emptyImagev, emptyImageh=dt.getShadowimg(h_dilate_img,x_count,y_count)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    #plt.subplot(2,1,1),plt.imshow(emptyImagev,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def removeStamp2(dstimg,maskimg=None,pointsTheshold=100,areathreshold = 20000.0,color = (255,255,255),debug=False):\n",
    "    dstimgT = dstimg.copy()\n",
    "    #if maskimg is None:\n",
    "        \n",
    "    imgrayT=cv2.Canny(dstimg,100,200,3)#Canny边缘检测，参数可更改\n",
    "    ret,maskimgT = cv2.threshold(imgrayT,10,255,cv2.THRESH_BINARY)  \n",
    "        \n",
    "    image, contours, hierarchy = cv2.findContours(maskimgT,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)#contours为轮廓集，可以计算轮廓的长度、面积等  \n",
    "    #emptyImageTT = np.zeros(maskimgT.shape, np.uint8)\n",
    "    if debug:\n",
    "        print(len(contours))\n",
    "    #print(3)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(image,'gray')\n",
    "        #plt.subplot(2,1,2),plt.imshow(maskimgT,'gray')\n",
    "\n",
    "\n",
    "        plt.show() \n",
    "    for cnt in contours:  \n",
    "        #print(len(cnt))\n",
    "        if len(cnt) > pointsTheshold:  \n",
    "            S1=cv2.contourArea(cnt)  \n",
    "            ell=cv2.fitEllipse(cnt)  \n",
    "            S2 =math.pi*ell[1][0]*ell[1][1]\n",
    "            #if debug:\n",
    "            #    print(S1,S2,ell)\n",
    "\n",
    "            if S2 > areathreshold and (S1/S2)>0.005 :#面积比例，可以更改，根据数据集。。。  \n",
    "                print(\"--\",S1,S2,ell)\n",
    "                #cv2.drawContours(emptyImageTT, cnt, -1, (255, 255, 255), 2)\n",
    "                cv2.ellipse(dstimgT, ell,color, 15)\n",
    "                cv2.ellipse(dstimgT, ell,color, cv2.FILLED)\n",
    "\n",
    "                \n",
    "    return dstimgT\n",
    "rotate_image = removeStamp2(rotate_image,debug=True)  \n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(rotate_image,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(emptyImageTT,'gray')\n",
    "\n",
    "\n",
    "    plt.show()            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rows,colums=dt.getGrid(emptyImagev,x_segmentation,y_segmentation)\n",
    "x1= 0\n",
    "y1= rows[0]\n",
    "x2= rotate_image.shape[1]-1\n",
    "y2= rows[-1]\n",
    "print(x_segmentation,y_segmentation)\n",
    "print(rows,colums)\n",
    "print(\"共{}行{}列\".format(len(rows),len(colums)))\n",
    "tablerect = rotate_image[y1+5:y2-5, x1+10:x2-10]\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gaussianimg = cv2.GaussianBlur(tablerect,(3,3),0)\n",
    "sobel = cv2.Sobel(gaussianimg, cv2.CV_8U, 1, 0, ksize = 3)\n",
    "ret, binary = cv2.threshold(sobel, 20, 255, cv2.THRESH_OTSU+cv2.THRESH_BINARY)\n",
    "text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (17, 11))  # 形态学因子\n",
    "text_structureH = cv2.getStructuringElement(\n",
    "    cv2.MORPH_CROSS, (17, 1)) \n",
    "text_structureX = cv2.getStructuringElement(\n",
    "    cv2.MORPH_CROSS, (5, 5))\n",
    "h_dilate_imgT = cv2.dilate(binary, text_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, text_structureX, 1)\n",
    "h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "\n",
    "h_threshold = int(tablerect.shape[0]/10)\n",
    "v_threshold = int(tablerect.shape[1]/15)\n",
    "print(h_threshold,v_threshold)\n",
    "x_count,x_segmentation = dt.verticalShadow(h_erode_img,h_threshold)\n",
    "y_count,y_segmentation = dt.horizontalShadow(h_dilate_img,v_threshold)\n",
    "\n",
    "print(len(x_segmentation))\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    emptyImagev, emptyImageh=dt.getShadowimg(tablerect,x_count,y_count)\n",
    "    plt.gcf().set_size_inches(40.0,40.0)\n",
    "    plt.subplot(2,2,1),plt.imshow(h_erode_img,'gray')\n",
    "    plt.subplot(2,2,2),plt.imshow(h_dilate_img,'gray')\n",
    "    plt.subplot(2,2,3),plt.imshow(emptyImagev,'gray')\n",
    "    plt.subplot(2,2,4),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "rows,colums=getGridabc(tablerect,x_segmentation,y_segmentation)\n",
    "print(len(rows),len(colums))\n",
    "if debug:\n",
    "    print(x_segmentation)\n",
    "    print(y_segmentation)\n",
    "    white = (255, 255, 255)\n",
    "    black = (0, 0, 0)\n",
    "    h,w=tablerect.shape\n",
    "    emptyImage1 = tablerect.copy()\n",
    "    for x in colums:\n",
    "        cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "    for y in rows:\n",
    "\n",
    "        cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.imshow(emptyImage1,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"    获取上下线的y坐标\")\n",
    "\n",
    "edges = cv2.Canny(rotate_image,50,150,apertureSize = 3)\n",
    "minLineLength=600\n",
    "scale = 10\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "text_structureH = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1)) \n",
    "text_structureV = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (5, 5))\n",
    "h_dilate_imgT = cv2.dilate(edges, text_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, text_structureH, 1)\n",
    "h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "lines = cv2.HoughLinesP(image=h_erode_img,rho=0.02,theta=np.pi/500, threshold=400,minLineLength=minLineLength,maxLineGap=180)\n",
    "empytImg = np.zeros(h_erode_img.shape, np.uint8)\n",
    "for line in lines: \n",
    "    #print(line)\n",
    "    x1,y1,x2,y2=line[0]\n",
    "    cv2.line(empytImg,(x1,y1),(x2,y2),(255,255,255),1)\n",
    "    \n",
    "#h_erode_img = cv2.erode(edges, h_structure, 1)\n",
    "#h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(h_erode_img,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(empytImg,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from BaiduAipOcr import BaiduAipOcr\n",
    "\n",
    "print('6：根据行列坐标转化每块到cell') \n",
    "\n",
    "\n",
    "\n",
    "#print(len(tablelist))\n",
    "#print(len(tablelist[0]))\n",
    "savename,extension = os.path.splitext(filename)\n",
    "tablelist = imgtotable(tablerect,rows,colums)\n",
    "df=pd.DataFrame(tablelist)\n",
    "tempoutpath=os.path.join(path,tempout)\n",
    "if not os.path.exists(tempoutpath):\n",
    "    os.makedirs(tempoutpath)\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "writer = pd.ExcelWriter(savepath)\n",
    "df.to_excel(writer, sheet_name=savename)\n",
    "writer.save()\n",
    "writer.close()\n",
    "print(\"ok\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/abctest/'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        sheet_data = ocrimgtoexcel(file,fpath,debug=False)\n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "        sheet_data.to_excel(writer, sheet_name=fname)\n",
    "        writer.save()\n",
    "    writer.close()   "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
