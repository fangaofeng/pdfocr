{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import os\n",
    "try:\n",
    "    import Image\n",
    "except ImportError:\n",
    "    from PIL import Image\n",
    "import cv2\n",
    "import numpy as np\n",
    "import pytesseract\n",
    "from matplotlib import pyplot as plt\n",
    "import math\n",
    "from math import radians, degrees\n",
    "from skewManger import imgproc\n",
    "from skewManger.common import ROTATION, SKEW_X, SKEW_Y, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL\n",
    "from tabledetect import detectTable\n",
    "import pandas as pd\n",
    "import json\n",
    "from BaiduAipOcr import BaiduAipOcr\n",
    "tempout = \"temp/\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# 根据mask 找出印章，覆盖dstimg 印章区域\n",
    "def removeStamp(dstimg,maskimg=None,pointsTheshold=100,areathreshold = 1000.0,color = (255,255,255),debug=False):\n",
    "    dstimgT = dstimg.copy()\n",
    "    #if maskimg is None:\n",
    "        \n",
    "    imgrayT=cv2.Canny(dstimg,100,200,3)#Canny边缘检测，参数可更改\n",
    "    ret,maskimgT = cv2.threshold(imgrayT,10,255,cv2.THRESH_BINARY)  \n",
    "        \n",
    "    image, contours, hierarchy = cv2.findContours(maskimgT,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)#contours为轮廓集，可以计算轮廓的长度、面积等  \n",
    "    #emptyImageTT = np.zeros(maskimgT.shape, np.uint8)\n",
    "    #print(len(contours))\n",
    "    #print(3)\n",
    "    #plt.gcf().set_size_inches(60.0,40.0)\n",
    "    #plt.subplot(2,1,1),plt.imshow(imgrayT,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(maskimgT,'gray')\n",
    "\n",
    "\n",
    "    #plt.show() \n",
    "    for cnt in contours:  \n",
    "        #print(len(cnt))\n",
    "        if len(cnt) > pointsTheshold:  \n",
    "            S1=cv2.contourArea(cnt)  \n",
    "            ell=cv2.fitEllipse(cnt)  \n",
    "            S2 =math.pi*ell[1][0]*ell[1][1] \n",
    "            #print(S2)\n",
    "            if S1 > areathreshold and (S1/S2)>0.005 :#面积比例，可以更改，根据数据集。。。  \n",
    "                print(S1,S2,ell)\n",
    "                #cv2.drawContours(emptyImageTT, cnt, -1, (255, 255, 255), 2)\n",
    "                cv2.ellipse(dstimgT, ell,color, 15)\n",
    "                cv2.ellipse(dstimgT, ell,color, cv2.FILLED)\n",
    "\n",
    "                \n",
    "    return dstimgT\n",
    "\n",
    "def imgtotable(img,rows,colums,debug=False):\n",
    "    ocrclient = BaiduAipOcr()\n",
    "    tablelist = [[\"\" for col in range(0,len(colums))] for row in range(0,len(rows))]\n",
    "    #print(tablelist)\n",
    "    for row, y in enumerate(rows):\n",
    "        print(\"行{}：\".format(row),end=\" \")\n",
    "        for colum,x in enumerate(colums):\n",
    "            if row == 0:\n",
    "                y1=0\n",
    "            else:\n",
    "                y1=rows[row-1]\n",
    "            if colum == 0:\n",
    "                x1=0\n",
    "            else:\n",
    "                x1=colums[colum-1]\n",
    "            x2=x\n",
    "            y2=y\n",
    "            roiimg = img[y1:y2,\n",
    "                  x1:x2]\n",
    "\n",
    "            if debug:\n",
    "                \n",
    "                cv2.imwrite(\"testimage/{}{}.jpg\".format(row,colum),roiimg)\n",
    "\n",
    "            try:\n",
    "                print(\"列{}：\".format(colum),end=\" \")\n",
    "                if debug:\n",
    "                    text=\"err\"\n",
    "                    \n",
    "                else:\n",
    "                    text = ocrclient.image_to_stringforcv2(roiimg)\n",
    "            except Exception as e:\n",
    "                #print(e)\n",
    "                print(\"RECT:[{}:{},{}:{}]\".format(\n",
    "                    y1, y2, x1, x2))\n",
    "                text = \"error\"\n",
    "            #print(row,colum)\n",
    "            tablelist[row][colum] = text\n",
    "        print(\" \".format(row))\n",
    "        #print(\"\")\n",
    "    return tablelist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "def ocrimgtoexcel(filename,path,debug=False ):\n",
    "    print('1：读取文件{}'.format(filename))\n",
    "    filepath=os.path.join(path,filename)\n",
    "    iproc_obj = imgproc.ImageProc(filepath)\n",
    "    print(iproc_obj.input_img.shape)\n",
    "    print('2：检测水平线和角度')\n",
    "    sum = 0.0\n",
    "    number = 0\n",
    "    lines_hough = iproc_obj.detect_lines(canny_low_thresh=150, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                         hough_rho_res=1,\n",
    "                                         hough_theta_res=np.pi/550,\n",
    "                                         hough_votes_thresh=650)\n",
    "\n",
    "\n",
    "    img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "    theta_rotate = iproc_obj.find_rotation_or_skew(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "    angle = degrees(theta_rotate[1])\n",
    "    print(\"-----方向{} 校正角度 {}\".format(theta_rotate[0],angle))\n",
    "    #theta_rotateV = iproc_obj.find_rotation_or_skew(only_direction=DIRECTION_VERTICAL)\n",
    "    #print(\"-----垂直校正角度 {}\".format(theta_rotate))\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(img_lines,\"gray\")\n",
    "        plt.show()\n",
    "    print('3：水平校正')\n",
    "    rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,-angle)\n",
    "    print(rotate_image.shape)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(rotate_image,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "    print('4：检测表格上下横线')\n",
    "    dt = detectTable(rotate_image)\n",
    "    thresh_img = cv2.adaptiveThreshold(\n",
    "        rotate_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 35, 3)\n",
    "    h_img = thresh_img.copy()\n",
    "    hscale = 10\n",
    "    h_size = int(h_img.shape[1]/hscale)\n",
    "\n",
    "    h_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "    h_dashed_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, 1))  # 形态学因子\n",
    "    h_dilate_imgT = cv2.dilate(h_img, h_dashed_structure, 1) # 虚线转为实线\n",
    "    h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1) #腐蚀掉非水平的对象\n",
    "    h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "    \n",
    "    \n",
    "    v_img = thresh_img.copy()\n",
    "    vscale = 10\n",
    "    v_size = int(v_img.shape[1]/vscale)\n",
    "\n",
    "    v_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, v_size))  # 形态学因子\n",
    "    v_dashed_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, 1))  # 形态学因子\n",
    "    v_dilate_imgT = cv2.dilate(v_img, v_dashed_structure, 1) # 虚线转为实线\n",
    "    v_erode_img = cv2.erode(v_dilate_imgT, v_structure, 1) #腐蚀掉非水平的对象\n",
    "    v_dilate_img = cv2.dilate(v_erode_img, v_structure, 1)\n",
    "    mask = h_dilate_img + v_dilate_img\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(90,50)\n",
    "        plt.subplot(2,1,1),plt.imshow(mask,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(thresh_img,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "\n",
    "    print('5：计算表格上下线坐标')\n",
    "    border =1\n",
    "    dtable = detectTable(rotate_image)\n",
    "    h_threshold = int(rotate_image.shape[0]/8)\n",
    "    v_threshold = int(rotate_image.shape[1]/10)\n",
    "    x_count,x_segmentation = dtable.verticalShadowSplite(v_dilate_img,v_threshold)\n",
    "    y_count,y_segmentation = dtable.horizontalShadowSplite(h_dilate_img,h_threshold)\n",
    "\n",
    "    #print(len(x_segmentation))\n",
    "    #print(len(y_segmentation))\n",
    "    if debug:\n",
    "        emptyImagev=dtable.getShadowimg(rotate_image,x_count,'V')\n",
    "        emptyImageh=dtable.getShadowimg(rotate_image,y_count,'H')\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(emptyImageh,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    rows=dt.getLineCor(rotate_image.shape[0],y_segmentation)    \n",
    "    colums=dt.getLineCor(rotate_image.shape[1],x_segmentation)  \n",
    "    x1= colums[0]-border\n",
    "    y1= rows[0]-border    # 切掉周边，避免干扰\n",
    "    x2= colums[-1]+border\n",
    "    y2= rows[-1]+border\n",
    "\n",
    "    print(\"上坐标线y1={},下坐标线y2={}\".format(y1,y2))\n",
    "    #rotate_image = removeStamp(rotate_image)  #去掉印章\n",
    "    tablerect = rotate_image[y1:y2, x1:x2] #获取表格部分\n",
    "    mask = mask[y1:y2, x1:x2]\n",
    "    if debug:\n",
    "        print(\"共{}行{}列\".format(len(rows),len(colums)))\n",
    "        print(x_segmentation,y_segmentation)\n",
    "        print(rows,colums)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "\n",
    "        plt.show()\n",
    "\n",
    "    print('6：图像高斯过滤')\n",
    "    #dt = detectTable(tablerect)\n",
    "    \"\"\"\n",
    "    H_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, 7))  # 形态学因子\n",
    "    dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 3))  # 形态学因子\n",
    "    maskT = cv2.erode(mask, dashed_structure, 1)\n",
    "    maskT = cv2.dilate(maskT, H_structure, 1)\n",
    "    \"\"\"\n",
    "    maskT = mask\n",
    "    tableImgNoborder = cv2.add(maskT,tablerect) # 去掉边界\n",
    "\n",
    "    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(9,9))\n",
    "    cl1 = clahe.apply(tableImgNoborder)\n",
    "    sigma = 1; threshold = 3; amount = 1\n",
    "    blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "\n",
    "    lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "    sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "    tableImgClear=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(40.0,70.0)\n",
    "        plt.subplot(3,1,1),plt.imshow(maskT,'gray')\n",
    "        plt.subplot(3,1,2),plt.imshow(blurred,'gray')\n",
    "        plt.subplot(3,1,3),plt.imshow(tableImgClear,'gray')\n",
    "        plt.show()\n",
    "\n",
    "\n",
    "\n",
    "   \n",
    "    print('7：计算行和列分割线')\n",
    "    dt = detectTable(tableImgClear)\n",
    "    h_threshold = int(tableImgClear.shape[1]/6)\n",
    "    v_threshold = int(tableImgClear.shape[0]/7)\n",
    "\n",
    "    x_count,x_segmentation = dt.verticalShadowSplite(mask,v_threshold)\n",
    "    y_count,y_segmentation = dt.horizontalShadowSplite(mask,h_threshold)\n",
    "    rows=dt.getLineCor(tableImgClear.shape[0],y_segmentation)\n",
    "    colums=dt.getLineCor(tableImgClear.shape[1],x_segmentation)\n",
    "    if tableImgClear.shape[0] - rows[-1] >20:\n",
    "        rows.append(tableImgClear.shape[0]-1)\n",
    "    if tableImgClear.shape[1] - colums[-1] >20:    \n",
    "        colums.append(tableImgClear.shape[1]-1)\n",
    "    print(len(rows),len(colums))\n",
    "    if debug:\n",
    "        emptyImagev=dt.getShadowimg(tableImgClear,x_count,'V')\n",
    "        emptyImageh=dt.getShadowimg(tableImgClear,y_count,'H')\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        h,w=tableImgClear.shape\n",
    "        emptyImage = tableImgClear.copy()\n",
    "        for x in colums:\n",
    "            cv2.line(emptyImage, (x, 0), (x, h), black)\n",
    "        for y in rows:\n",
    "\n",
    "            cv2.line(emptyImage, (0, y), (w, y), black)\n",
    "        plt.gcf().set_size_inches(60.0,90.0)\n",
    "        plt.subplot(3,1,1),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(3,1,2),plt.imshow(emptyImageh,'gray')\n",
    "        plt.subplot(3,1,3),plt.imshow(emptyImage,'gray')\n",
    "        plt.show()\n",
    "\n",
    "\n",
    "    # 临时文件保存名    \n",
    "    savename,extension = os.path.splitext(filename)\n",
    "    tempoutpath=os.path.join(path,tempout)\n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')      \n",
    "    print('8：每个cell进行识别的tablelist') \n",
    "    \n",
    "    tablelist = imgtotable(tableImgNoborder,rows,colums,debug)\n",
    "    print('9：保存文件')       \n",
    "    \n",
    "    \n",
    "    df=pd.DataFrame(tablelist)\n",
    "    \n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "    writer = pd.ExcelWriter(savepath)\n",
    "    df.to_excel(writer, sheet_name=savename)\n",
    "    writer.save()\n",
    "    writer.close()\n",
    "    print('10：{}.jpg '.format(savename))\n",
    "    \n",
    "    return tablelist\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'I:/陈宁/对账单/7建设金行金'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "all_tablelist = []\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        tablelist = ocrimgtoexcel(file,fpath,debug=False)\n",
    "        all_tablelist.append(['No {} page'.format(fname)])\n",
    "        all_tablelist.extend(tablelist)\n",
    "        \n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "sheet_data=pd.DataFrame(all_tablelist)\n",
    "sheet_data.to_excel(writer, sheet_name=fname)\n",
    "writer.save()\n",
    "writer.close()  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "path = 'I:/陈宁/对账单/7建设金行金'\n",
    "filename=\"7建设金行金_页面_15.jpg\"\n",
    "ocrimgtoexcel(filename,path,debug=True)\n",
    "print('ok')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import os\n",
    "debug = True\n",
    "path = 'j:/icbc0397/'\n",
    "filename=\"02.jpg\"\n",
    "\n",
    "print('1：读取文件')\n",
    "filepath=os.path.join(path,filename)\n",
    "iproc_obj = imgproc.ImageProc(filepath)\n",
    "print(iproc_obj.input_img.shape)\n",
    "print(iproc_obj.gray_img.shape)\n",
    "print('2：检测水平线和角度')\n",
    "sum = 0.0\n",
    "number = 0\n",
    "hough_rho_res=1\n",
    "hough_theta_res=np.pi/300\n",
    "hough_votes_thresh=150\n",
    "lines_hough = iproc_obj.detect_lines(canny_low_thresh=150, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                     hough_rho_res=1,\n",
    "                                     hough_theta_res=np.pi/750,\n",
    "                                     hough_votes_thresh=850)\n",
    "\n",
    "\"\"\"\n",
    "imgrayT=cv2.Canny(iproc_obj.gray_img,50,250,3)#Canny边缘检测，参数可更改\n",
    "# detect lines with hough transform\n",
    "lines = cv2.HoughLines(imgrayT, hough_rho_res,\n",
    "                       hough_theta_res, hough_votes_thresh)\n",
    "\"\"\"\n",
    "img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "\n",
    "#theta_rotate = iproc_obj.find_rotation_or_skew()\n",
    "\n",
    "theta_rotate = iproc_obj.find_rotation_or_skew(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "angle = -degrees(theta_rotate[1])\n",
    "\n",
    "print(\"-----校正角度 {}\".format(angle))\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(img_lines,\"gray\")\n",
    "    plt.show()\n",
    "print('3：水平校正')\n",
    "\n",
    "rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,angle)\n",
    "print(rotate_image.shape)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(rotate_image,'gray')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('4：检测表格上下横线')\n",
    "thresh_img = cv2.adaptiveThreshold(\n",
    "    rotate_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 35, 3)\n",
    "h_img = thresh_img.copy()\n",
    "scale = 8\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "h_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))\n",
    "erode_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))# 形态学因子\n",
    "h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1)\n",
    "h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_img, erode_structure, 1)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(90,90)\n",
    "    plt.subplot(3,1,1),plt.imshow(thresh_img,'gray')\n",
    "    plt.subplot(3,1,2),plt.imshow(h_dilate_imgT,'gray')\n",
    "    plt.subplot(3,1,3),plt.imshow(h_erode_img,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "dt = detectTable(rotate_image)\n",
    "print('5：获取表格的最大矩形') \n",
    "\n",
    "#y_count,y_segmentation = dt.horizontalShadowSplite(h_erode_img,300)\n",
    "#rectlist = dt.getTableRois(erode_img)\n",
    "minarea =1000\n",
    "image, contours, hierarchy = cv2.findContours(\n",
    "            h_erode_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_TC89_L1)\n",
    "\n",
    "regroi = []\n",
    "cntlsit = np.concatenate([cnt for cnt in contours ])\n",
    "rectmaxX, rectmaxY,rectmaxW,rectmaxH = cv2.boundingRect(cntlsit)\n",
    "\n",
    "#rect = cv2.minAreaRect(cntlsit)  \n",
    "#print(rect)\n",
    "#box = cv2.boxPoints(rect)\n",
    "#box = np.int0(box)  \n",
    "\n",
    "if debug:\n",
    "    emptyImage=rotate_image.copy()\n",
    "    emptyImage = cv2.cvtColor(emptyImage, cv2.COLOR_GRAY2RGB)\n",
    "    #cv2.drawContours(emptyImage, [box], 0, (0, 0, 255), 2) \n",
    "    cv2.rectangle(emptyImage,(rectmaxX,rectmaxY),(rectmaxX+rectmaxW,rectmaxY+rectmaxH),(255,0,0),1)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(1,1,1),plt.imshow(emptyImage)\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "border =0\n",
    "#rows=dt.getLineCor(emptyImageh.shape[0],y_segmentation)\n",
    "#x1= 0\n",
    "#y1= rows[0]\n",
    "#x2= rotate_image.shape[1]-1\n",
    "#y2= rows[-1]\n",
    "#print(y_segmentation)\n",
    "#print(rows)\n",
    "#print(\"共{}\".format(len(rows)))\n",
    "\n",
    "tablerect = rotate_image[rectmaxY+border:rectmaxY+rectmaxH-border, rectmaxX+border:rectmaxX+rectmaxW-border]\n",
    "mask = erode_img[rectmaxY+border:rectmaxY+rectmaxH-border, rectmaxX+border:rectmaxX+rectmaxW-border]\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(mask,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tablethresh_img = cv2.adaptiveThreshold(\n",
    "    tablerect, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 35, 3)\n",
    "v_img = tablethresh_img.copy()\n",
    "scale = 5\n",
    "v_size = int(v_img.shape[1]/scale)\n",
    "v_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (1,v_size))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 3))\n",
    "erode_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 3))# 形态学因子\n",
    "v_dilate_imgT = cv2.dilate(v_img, dashed_structure, 1)\n",
    "v_erode_img = cv2.erode(v_dilate_imgT, v_structure, 1)\n",
    "v_dilate_img = cv2.dilate(v_erode_img, v_structure, 1)\n",
    "v_erode_img = cv2.erode(v_dilate_img, erode_structure, 1)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(v_dilate_imgT,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(v_erode_img,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "H_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (1, 7))  # 形态学因子\n",
    "\n",
    "maskT = cv2.erode(mask, dashed_structure, 1)\n",
    "\"\"\"\n",
    "dilate_structure = cv2.getStructuringElement(\n",
    "cv2.MORPH_RECT, (3, 3))  # 形态学因子\n",
    "print(mask.shape,v_erode_img.shape)\n",
    "maskT = cv2.add(mask,v_erode_img)\n",
    "maskT = cv2.dilate(maskT, dilate_structure, 1)\n",
    "tablerectimg = cv2.add(maskT,tablerect)\n",
    "print(maskT.shape)\n",
    "print(tablerect.shape)\n",
    "clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n",
    "cl1 = clahe.apply(tableimg)\n",
    "sigma = 1; threshold = 3; amount = 1\n",
    "blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "\n",
    "lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "tableimage=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "\n",
    "\n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(3,1,1),plt.imshow(maskT,'gray')\n",
    "    plt.subplot(3,1,2),plt.imshow(tablerectimg,'gray')\n",
    "    plt.subplot(3,1,3),plt.imshow(tableimage,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "print('8：test') \n",
    "\n",
    "#thresh_img = cv2.adaptiveThreshold(\n",
    "#    tableimage, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 45, 3)\n",
    "ret, thresh_img = cv2.threshold(\n",
    "                tablerectimg, 210, 255, cv2.THRESH_BINARY_INV)\n",
    "element1 = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 3))\n",
    "element2 = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 9))\n",
    "element3 = cv2.getStructuringElement(cv2.MORPH_RECT, (9, 5))\n",
    "# 4. 膨胀一次，让轮廓突出 \n",
    "dilation = cv2.dilate(thresh_img, element1, iterations = 1)\n",
    "# 5. 腐蚀一次，去掉细节，如表格线等。注意这里去掉的是竖直的线 \n",
    "erosion = cv2.erode(dilation, element2, iterations = 1) \n",
    "# 6. 再次膨胀，让轮廓明显一些 \n",
    "dilation2 = cv2.dilate(erosion, element3, iterations = 3)\n",
    "\n",
    "\"\"\"\n",
    "dilate_structure = cv2.getStructuringElement(\n",
    "cv2.MORPH_RECT, (1, 3)) \n",
    "thresh_img = cv2.dilate(thresh_img, dilate_structure, 1)\n",
    "\"\"\"\n",
    "minarea =100\n",
    "image, contours, hierarchy = cv2.findContours(\n",
    "            dilation2, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE )\n",
    "\n",
    "\n",
    "regroi = []\n",
    "for i in range(len(contours)):\n",
    "    cnt = contours[i]\n",
    "    area = cv2.contourArea(cnt)\n",
    "    if area < minarea:\n",
    "        continue\n",
    "    epsilon = 0.1 * cv2.arcLength(cnt, True)\n",
    "    # print(epsilon)\n",
    "    approx = cv2.approxPolyDP(cnt, 10, True)\n",
    "    # print(approx)\n",
    "    regroi.append(cv2.boundingRect(approx)) \n",
    "\n",
    "if debug:\n",
    "    emptyImage=tablerectimg.copy()\n",
    "    emptyImage = cv2.cvtColor(emptyImage, cv2.COLOR_GRAY2RGB)\n",
    "    #cv2.drawContours(emptyImage, contours, -1, (0, 0, 255), 2) \n",
    "    for x,y,w,h in regroi:\n",
    "        cv2.rectangle(emptyImage,(x,y),(x+w,y+h),(255,0,0),1)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(dilation2,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(emptyImage)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "h_threshold = int(tablerectimg.shape[0]/3)\n",
    "v_threshold = int(tablerectimg.shape[1]/4)\n",
    "\n",
    "x_count,x_segmentation = dt.verticalShadowSplite(v_erode_img,v_threshold)\n",
    "y_count,y_segmentation = dt.horizontalShadowSplite(mask,h_threshold)\n",
    "rows=dt.getLineCor(tablerectimg.shape[0],y_segmentation)\n",
    "colums=dt.getLineCor(tablerectimg.shape[1],x_segmentation)\n",
    "print(len(rows),len(colums))\n",
    "if debug:\n",
    "    emptyImagev=dt.getShadowimg(tablerectimg,x_count,'V')\n",
    "    emptyImageh=dt.getShadowimg(tablerectimg,y_count,'H')\n",
    "    white = (255, 255, 255)\n",
    "    black = (0, 0, 0)\n",
    "    h,w=tablerectimg.shape\n",
    "    emptyImage1 = tablerectimg.copy()\n",
    "    for x in colums:\n",
    "        cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "    for y in rows:\n",
    "\n",
    "        cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "    plt.gcf().set_size_inches(60.0,90.0)\n",
    "    plt.subplot(3,1,1),plt.imshow(emptyImagev,'gray')\n",
    "    plt.subplot(3,1,2),plt.imshow(emptyImageh,'gray')\n",
    "    plt.subplot(3,1,3),plt.imshow(emptyImage1,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"    获取上下线的y坐标\")\n",
    "\n",
    "edges = cv2.Canny(rotate_image,50,150,apertureSize = 3)\n",
    "minLineLength=600\n",
    "scale = 10\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "text_structureH = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1)) \n",
    "text_structureV = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (5, 5))\n",
    "h_dilate_imgT = cv2.dilate(edges, text_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, text_structureH, 1)\n",
    "h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "lines = cv2.HoughLinesP(image=h_erode_img,rho=0.02,theta=np.pi/500, threshold=400,minLineLength=minLineLength,maxLineGap=180)\n",
    "empytImg = np.zeros(h_erode_img.shape, np.uint8)\n",
    "for line in lines: \n",
    "    #print(line)\n",
    "    x1,y1,x2,y2=line[0]\n",
    "    cv2.line(empytImg,(x1,y1),(x2,y2),(255,255,255),1)\n",
    "    \n",
    "#h_erode_img = cv2.erode(edges, h_structure, 1)\n",
    "#h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(h_erode_img,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(empytImg,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from BaiduAipOcr import BaiduAipOcr\n",
    "\n",
    "print('6：根据行列坐标转化每块到cell') \n",
    "\n",
    "\n",
    "\n",
    "#print(len(tablelist))\n",
    "#print(len(tablelist[0]))\n",
    "savename,extension = os.path.splitext(filename)\n",
    "tablelist = imgtotable(tablerectimg,rows,colums,debug=True)\n",
    "df=pd.DataFrame(tablelist)\n",
    "tempoutpath=os.path.join(path,tempout)\n",
    "if not os.path.exists(tempoutpath):\n",
    "    os.makedirs(tempoutpath)\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "writer = pd.ExcelWriter(savepath)\n",
    "df.to_excel(writer, sheet_name=savename)\n",
    "writer.save()\n",
    "writer.close()\n",
    "print(\"ok\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "debug = True\n",
    "path = 'j:/icbc/'\n",
    "filename=\"2.jpg\"\n",
    "\n",
    "print('1：读取文件')\n",
    "filepath=os.path.join(path,filename)\n",
    "img = cv2.imread(filepath,0)\n",
    "# create a CLAHE object (Arguments are optional).\n",
    "clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n",
    "cl1 = clahe.apply(img)\n",
    "sigma = 1; threshold = 3; amount = 1\n",
    "blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "#blurred1 = cv2.adaptiveThreshold(\n",
    "#    blurred, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "image=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "plt.gcf().set_size_inches(50.0,60.0)\n",
    "plt.subplot(2,1,1),plt.imshow(blurred,'gray')\n",
    "plt.subplot(2,1,2),plt.imshow(image,'gray')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "hist,bins = np.histogram(img.flatten(),256,[0,256])\n",
    "cdf = hist.cumsum()\n",
    "cdf_normalized = cdf * float(hist.max()) / cdf.max()\n",
    "plt.plot(cdf_normalized, color = 'b')\n",
    "plt.hist(img.flatten(),256,[0,256], color = 'r')\n",
    "plt.xlim([0,256])\n",
    "plt.legend(('cdf','histogram'), loc = 'upper left')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "img = cv2.imread(filepath,0)\n",
    "equ = cv2.equalizeHist(img)\n",
    "res = np.hstack((img,equ)) #stacking images side-by-side\n",
    "plt.gcf().set_size_inches(60.0,40.0)\n",
    "plt.subplot(2,1,1),plt.imshow(img,'gray')\n",
    "plt.subplot(2,1,2),plt.imshow(equ,'gray')\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
