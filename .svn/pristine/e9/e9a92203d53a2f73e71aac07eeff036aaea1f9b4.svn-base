{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import os\n",
    "try:\n",
    "    import Image\n",
    "except ImportError:\n",
    "    from PIL import Image\n",
    "import cv2\n",
    "import numpy as np\n",
    "#import pytesseract\n",
    "from matplotlib import pyplot as plt\n",
    "import math\n",
    "from math import radians, degrees\n",
    "from pdftabextract import imgproc\n",
    "from pdftabextract.common import ROTATION, SKEW_X, SKEW_Y, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL\n",
    "from tabledetect import detectTable, cutImage,roiToCell\n",
    "import pandas as pd\n",
    "import json\n",
    "from BaiduAipOcr import BaiduAipOcr\n",
    "tempout = \"temp/\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def imgtotable(img,rows,colums,debug=False):\n",
    "    ocrclient = BaiduAipOcr()\n",
    "    tablelist = [[\"\" for col in range(0,len(colums))] for row in range(0,len(rows))]\n",
    "    #print(tablelist)\n",
    "    for row, y in enumerate(rows):\n",
    "        print(\"行{}：\".format(row),end=\" \")\n",
    "        for colum,x in enumerate(colums):\n",
    "            if row == 0:\n",
    "                y1=0\n",
    "            else:\n",
    "                y1=rows[row-1]\n",
    "            if colum == 0:\n",
    "                x1=0\n",
    "            else:\n",
    "                x1=colums[colum-1]\n",
    "            x2=x\n",
    "            y2=y\n",
    "            roiimg = img[y1:y2,\n",
    "                  x1:x2]\n",
    "            if debug:\n",
    "                \n",
    "                cv2.imwrite(\"testimage/{}{}.jpg\".format(row,colum),roiimg)\n",
    "            try:\n",
    "                print(\"列{}：\".format(colum),end=\" \")\n",
    "                if debug:\n",
    "                    text=\"err\"\n",
    "                else:\n",
    "                    text = ocrclient.image_to_string(roiimg)\n",
    "            except Exception as e:\n",
    "                print(e)\n",
    "                print(\"RECT:[{}:{},{}:{}]\".format(\n",
    "                    y1, y2, x1, x2))\n",
    "                text = \"error\"\n",
    "            #print(row,colum)\n",
    "            tablelist[row][colum] = text\n",
    "        print(\"\")\n",
    "    return tablelist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "def ocrimgtoexcel(filename,path,debug=False ):\n",
    "    print('1：读取文件{}'.format(filename))\n",
    "    filepath=os.path.join(path,filename)\n",
    "    iproc_obj = imgproc.ImageProc(filepath)\n",
    "    print(iproc_obj.input_img.shape)\n",
    "    print('2：检测水平线和角度')\n",
    "    sum = 0.0\n",
    "    number = 0\n",
    "    lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                         hough_rho_res=1,\n",
    "                                         hough_theta_res=np.pi/600,\n",
    "                                         hough_votes_thresh=750)\n",
    "\n",
    "\n",
    "    img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(img_lines,\"gray\")\n",
    "        plt.show()\n",
    "    theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "    angle = degrees(theta_rotate[1])\n",
    "    print(\"-----方向{} 校正角度 {}\".format(theta_rotate[0],angle))\n",
    "\n",
    "\n",
    "    print('3：水平校正')\n",
    "    rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,-angle)\n",
    "    print(rotate_image.shape)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(rotate_image,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "    print('4：检测表格框')\n",
    "    dtable = detectTable(rotate_image)\n",
    "    hmask = dtable.getHmask()\n",
    "    vmask = dtable.getVmask()\n",
    "    mask = hmask+vmask\n",
    "\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(90,50)\n",
    "        plt.subplot(1,1,1),plt.imshow(mask,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    \n",
    "    print('5：获取表格区域')\n",
    "    tablerectlist = dtable.getTableRois(mask)\n",
    "    if(len(tablerectlist) != 1):\n",
    "        print(\"----------error：发现多个表格   -------------\")\n",
    "\n",
    "    \n",
    "    tableimg = dtable.getRoiImg(tablerectlist[0],border =-5)\n",
    "    tablemask = dtable.getRoiImg(tablerectlist[0],mask,border =-5)\n",
    "    tableHmask = dtable.getRoiImg(tablerectlist[0],hmask,border =-5)\n",
    "    tableVmask = dtable.getRoiImg(tablerectlist[0],vmask,border =-5)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(tableimg,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(tablemask,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    print('6：获取表格线的坐标')\n",
    "    h_threshold = int(tableimg.shape[0]/5)\n",
    "    v_threshold = int(tableimg.shape[1]/5)\n",
    "    x_count,x_segmentation = dtable.verticalShadowSplite(tableVmask,h_threshold,150)\n",
    "    y_count,y_segmentation = dtable.horizontalShadowSplite(tableHmask,v_threshold)\n",
    "    if debug:\n",
    "    #emptyImagev = cv2.dilate(emptyImagev, erode_structure, 1)\n",
    "        emptyImagev=dtable.getShadowimg(tableimg,x_count,'V')\n",
    "        emptyImageh=dtable.getShadowimg(tableimg,y_count,'H')\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(emptyImageh,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    print('7:--分割图片')\n",
    "    rows=dtable.getLineCor(tableimg.shape[0],y_segmentation)\n",
    "    rows.append(tableimg.shape[0]-1)\n",
    "    colums=dtable.getLineCor(tableimg.shape[1],x_segmentation)\n",
    "    colums.append(tableimg.shape[1]-1)\n",
    "    print(len(rows),len(colums))\n",
    "    if debug:\n",
    "        print(x_segmentation)\n",
    "        print(y_segmentation)\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        h,w=tableimg.shape\n",
    "        emptyImage1 = tableimg.copy()\n",
    "        for x in colums:\n",
    "            cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "        for y in rows:\n",
    "\n",
    "            cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.imshow(emptyImage1,'gray')\n",
    "        plt.show()\n",
    "\n",
    "    print(\"表格共{}行{}\".format(len(rows),len(colums)))\n",
    "    if debug:\n",
    "\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        h,w=tableimg.shape\n",
    "        emptyImage1 = tableimg.copy()\n",
    "        for x in colums:\n",
    "            cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "        for y in rows:\n",
    "\n",
    "            cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.imshow(emptyImage1,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "    tempoutpath=os.path.join(path,tempout)\n",
    "    savename,extension = os.path.splitext(filename)        \n",
    "    print('8：每个cell进行识别的tablelist') \n",
    "    H_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, 7))  # 形态学因子\n",
    "    x_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 3))  # 形态学因子\n",
    "    #maskT = cv2.erode(mask, dashed_structure, 1)\n",
    "    tablemaskT = cv2.dilate(tablemask, x_structure, 1)\n",
    "    tableImgNoborder = cv2.add(tablemaskT,tableimg)\n",
    "\n",
    "\n",
    "    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n",
    "    cl1 = clahe.apply(tableImgNoborder)\n",
    "    sigma = 1; threshold = 3; amount = 1\n",
    "    blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "    \n",
    "    lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "    sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "    tableblurred=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "    \n",
    "    if debug:\n",
    "        savejpg = os.path.join(tempoutpath,savename+'blured2.jpg')   \n",
    "        cv2.imwrite(savejpg,tableblurred)\n",
    "        plt.gcf().set_size_inches(40.0,40.0)\n",
    "        plt.subplot(3,1,1),plt.imshow(tablemaskT,'gray')\n",
    "        plt.subplot(3,1,2),plt.imshow(tableblurred,'gray')\n",
    "        plt.subplot(3,1,3),plt.imshow(tableImgNoborder,'gray')\n",
    "        plt.show()\n",
    "    tablelist = imgtotable(tableImgNoborder,rows,colums,debug)\n",
    "    print('9：保存文件')\n",
    "    \n",
    "    df=pd.DataFrame(tablelist)\n",
    "    \n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "    writer = pd.ExcelWriter(savepath)\n",
    "    df.to_excel(writer, sheet_name=savename)\n",
    "    writer.save()\n",
    "    writer.close()\n",
    "    print('9：{}.jpg '.format(savename))\n",
    "    \n",
    "    return df\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1：读取文件icbc0066_页面_13.jpg\n",
      "(1653, 2338, 3)\n",
      "2：检测水平线和角度\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING:root:no vertical lines found\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.005235954127039477 None True False\n",
      "-----方向sx 校正角度 0.29999807320346733\n",
      "3：水平校正\n",
      "points.length()=55776\n",
      "校正角度-0.29999807320346733--0.29999807320346733\n",
      "(1653, 2338)\n",
      "4：检测表格框\n",
      "5：获取表格区域\n",
      "6：获取表格线的坐标\n",
      "7:--分割图片\n",
      "9 12\n",
      "表格共9行12\n",
      "8：每个cell进行识别的tablelist\n",
      "行0： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行1： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行2： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行3： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行4： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行5： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行6： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行7： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "行8： 列0： 列1： 列2： 列3： 列4： 列5： 列6： 列7： 列8： 列9： 列10： 列11： \n",
      "9：保存文件\n",
      "9：icbc0066_页面_13.jpg \n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "      <th>1</th>\n",
       "      <th>2</th>\n",
       "      <th>3</th>\n",
       "      <th>4</th>\n",
       "      <th>5</th>\n",
       "      <th>6</th>\n",
       "      <th>7</th>\n",
       "      <th>8</th>\n",
       "      <th>9</th>\n",
       "      <th>10</th>\n",
       "      <th>11</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>记账日期</td>\n",
       "      <td>记账时间</td>\n",
       "      <td>币别</td>\n",
       "      <td>金额</td>\n",
       "      <td>余额</td>\n",
       "      <td>交易名称</td>\n",
       "      <td>渠道</td>\n",
       "      <td>网点名称</td>\n",
       "      <td>附营</td>\n",
       "      <td>对方账户名</td>\n",
       "      <td>对方卡号/账号</td>\n",
       "      <td>对方开户行</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2018-04-06</td>\n",
       "      <td>03:15:34</td>\n",
       "      <td>人民币</td>\n",
       "      <td>-3.00</td>\n",
       "      <td>1.13</td>\n",
       "      <td>批量收费</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2018-01-06</td>\n",
       "      <td>03:36:40</td>\n",
       "      <td>人民币</td>\n",
       "      <td>3.00</td>\n",
       "      <td>4.13</td>\n",
       "      <td>批量收费</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2017-12-20</td>\n",
       "      <td>22:52:35</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.0l</td>\n",
       "      <td>7.13</td>\n",
       "      <td>结息</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>20l7-09-20</td>\n",
       "      <td>22:52:47</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.01</td>\n",
       "      <td>7.12</td>\n",
       "      <td>结息</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>2017-06-20</td>\n",
       "      <td>22:41:32</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.01</td>\n",
       "      <td>7.II</td>\n",
       "      <td>结息</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td>-----------------</td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>2017-03-20</td>\n",
       "      <td>22:42:36</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.01</td>\n",
       "      <td>7.10</td>\n",
       "      <td>结息</td>\n",
       "      <td></td>\n",
       "      <td>一一</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>2016-12-20</td>\n",
       "      <td>22:41:4</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.0l</td>\n",
       "      <td>7.09</td>\n",
       "      <td>结息</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>2016-09-20</td>\n",
       "      <td>22:37:53</td>\n",
       "      <td>人民币</td>\n",
       "      <td>0.0l</td>\n",
       "      <td>7.08</td>\n",
       "      <td>息</td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "      <td></td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "            0          1     2       3      4      5    6      7    8   \\\n",
       "0         记账日期       记账时间    币别      金额     余额   交易名称   渠道   网点名称   附营   \n",
       "1   2018-04-06   03:15:34   人民币   -3.00   1.13   批量收费                    \n",
       "2   2018-01-06   03:36:40   人民币    3.00   4.13   批量收费                    \n",
       "3   2017-12-20   22:52:35   人民币    0.0l   7.13     结息                    \n",
       "4   20l7-09-20   22:52:47   人民币    0.01   7.12     结息                    \n",
       "5   2017-06-20   22:41:32   人民币    0.01   7.II     结息                    \n",
       "6   2017-03-20   22:42:36   人民币    0.01   7.10     结息          一一        \n",
       "7   2016-12-20    22:41:4   人民币    0.0l   7.09     结息                    \n",
       "8   2016-09-20   22:37:53   人民币    0.0l   7.08      息                    \n",
       "\n",
       "       9                   10      11  \n",
       "0   对方账户名             对方卡号/账号   对方开户行  \n",
       "1                                      \n",
       "2                                      \n",
       "3                                      \n",
       "4                                      \n",
       "5           -----------------          \n",
       "6                                      \n",
       "7                                      \n",
       "8                                      "
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "path = 'j:/icbc/'\n",
    "filename=\"icbc0066_页面_13.jpg\"\n",
    "ocrimgtoexcel(filename,path,debug=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/cmbc/'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        sheet_data = ocrimgtoexcel(file,fpath,debug=False)\n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "        sheet_data.to_excel(writer, sheet_name=fname)\n",
    "    writer.save()\n",
    "    writer.close()  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import os\n",
    "debug = True\n",
    "path = 'j:/cmbc/'\n",
    "filename=\"cmbc_页面_1.jpg\"\n",
    "\n",
    "print('1：读取文件')\n",
    "filepath=os.path.join(path,filename)\n",
    "iproc_obj = imgproc.ImageProc(filepath)\n",
    "print(iproc_obj.input_img.shape)\n",
    "print(iproc_obj.gray_img.shape)\n",
    "print('2：检测水平线和角度')\n",
    "sum = 0.0\n",
    "number = 0\n",
    "hough_rho_res=1\n",
    "hough_theta_res=np.pi/300\n",
    "hough_votes_thresh=150\n",
    "lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                     hough_rho_res=1,\n",
    "                                     hough_theta_res=np.pi/600,\n",
    "                                     hough_votes_thresh=750)\n",
    "\n",
    "\"\"\"\n",
    "imgrayT=cv2.Canny(iproc_obj.gray_img,50,250,3)#Canny边缘检测，参数可更改\n",
    "# detect lines with hough transform\n",
    "lines = cv2.HoughLines(imgrayT, hough_rho_res,\n",
    "                       hough_theta_res, hough_votes_thresh)\n",
    "\"\"\"\n",
    "img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "\n",
    "#theta_rotate = iproc_obj.find_rotation_or_skew()\n",
    "\n",
    "theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=2)\n",
    "angle = -degrees(theta_rotate[1])\n",
    "\n",
    "print(\"-----校正角度 {}\".format(angle))\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(img_lines,\"gray\")\n",
    "    plt.show()\n",
    "print('3：水平校正')\n",
    "\n",
    "rotate_image = iproc_obj.rotate_image(iproc_obj.gray_img,angle)\n",
    "print(rotate_image.shape)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(rotate_image,'gray')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tx=img_lines.shape\n",
    "print(tx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(degrees(0.00987357712749924))\n",
    "print(degrees(0.0062832077357430904))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('4：检测表格上下横线')\n",
    "thresh_img = cv2.adaptiveThreshold(\n",
    "    ~rotate_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "h_img = thresh_img.copy()\n",
    "scale = 10\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "h_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1)\n",
    "h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(90,50)\n",
    "    plt.subplot(2,1,1),plt.imshow(h_dilate_imgT,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(h_erode_img,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dt = detectTable(rotate_image)\n",
    "print('5：计算行和列分割线') \n",
    "x_count,x_segmentation = dt.verticalShadow(h_erode_img,200)\n",
    "y_count,y_segmentation = dt.horizontalShadow(h_erode_img,300)\n",
    "\n",
    "print(len(x_segmentation))\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    #emptyImagev, emptyImageh=dt.getShadowimg(h_dilate_img,x_count,y_count)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    #plt.subplot(2,1,1),plt.imshow(emptyImagev,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def removeStamp2(dstimg,maskimg=None,pointsTheshold=100,areathreshold = 20000.0,color = (255,255,255),debug=False):\n",
    "    dstimgT = dstimg.copy()\n",
    "    #if maskimg is None:\n",
    "        \n",
    "    imgrayT=cv2.Canny(dstimg,100,200,3)#Canny边缘检测，参数可更改\n",
    "    ret,maskimgT = cv2.threshold(imgrayT,10,255,cv2.THRESH_BINARY)  \n",
    "        \n",
    "    image, contours, hierarchy = cv2.findContours(maskimgT,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)#contours为轮廓集，可以计算轮廓的长度、面积等  \n",
    "    #emptyImageTT = np.zeros(maskimgT.shape, np.uint8)\n",
    "    if debug:\n",
    "        print(len(contours))\n",
    "    #print(3)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(image,'gray')\n",
    "        #plt.subplot(2,1,2),plt.imshow(maskimgT,'gray')\n",
    "\n",
    "\n",
    "        plt.show() \n",
    "    for cnt in contours:  \n",
    "        #print(len(cnt))\n",
    "        if len(cnt) > pointsTheshold:  \n",
    "            S1=cv2.contourArea(cnt)  \n",
    "            ell=cv2.fitEllipse(cnt)  \n",
    "            S2 =math.pi*ell[1][0]*ell[1][1]\n",
    "            #if debug:\n",
    "            #    print(S1,S2,ell)\n",
    "\n",
    "            if S2 > areathreshold and (S1/S2)>0.005 :#面积比例，可以更改，根据数据集。。。  \n",
    "                print(\"--\",S1,S2,ell)\n",
    "                #cv2.drawContours(emptyImageTT, cnt, -1, (255, 255, 255), 2)\n",
    "                cv2.ellipse(dstimgT, ell,color, 15)\n",
    "                cv2.ellipse(dstimgT, ell,color, cv2.FILLED)\n",
    "\n",
    "                \n",
    "    return dstimgT\n",
    "rotate_image = removeStamp2(rotate_image,debug=True)  \n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(rotate_image,'gray')\n",
    "    #plt.subplot(2,1,2),plt.imshow(emptyImageTT,'gray')\n",
    "\n",
    "\n",
    "    plt.show()            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rows,colums=dt.getGrid(emptyImagev,x_segmentation,y_segmentation)\n",
    "x1= 0\n",
    "y1= rows[0]\n",
    "x2= rotate_image.shape[1]-1\n",
    "y2= rows[-1]\n",
    "print(x_segmentation,y_segmentation)\n",
    "print(rows,colums)\n",
    "print(\"共{}行{}列\".format(len(rows),len(colums)))\n",
    "tablerect = rotate_image[y1+5:y2-5, x1+10:x2-10]\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gaussianimg = cv2.GaussianBlur(tablerect,(3,3),0)\n",
    "sobel = cv2.Sobel(gaussianimg, cv2.CV_8U, 1, 0, ksize = 3)\n",
    "ret, binary = cv2.threshold(sobel, 20, 255, cv2.THRESH_OTSU+cv2.THRESH_BINARY)\n",
    "text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (17, 11))  # 形态学因子\n",
    "text_structureH = cv2.getStructuringElement(\n",
    "    cv2.MORPH_CROSS, (17, 1)) \n",
    "text_structureX = cv2.getStructuringElement(\n",
    "    cv2.MORPH_CROSS, (5, 5))\n",
    "h_dilate_imgT = cv2.dilate(binary, text_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, text_structureX, 1)\n",
    "h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "\n",
    "h_threshold = int(tablerect.shape[0]/10)\n",
    "v_threshold = int(tablerect.shape[1]/15)\n",
    "print(h_threshold,v_threshold)\n",
    "x_count,x_segmentation = dt.verticalShadow(h_erode_img,h_threshold)\n",
    "y_count,y_segmentation = dt.horizontalShadow(h_dilate_img,v_threshold)\n",
    "\n",
    "print(len(x_segmentation))\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    emptyImagev, emptyImageh=dt.getShadowimg(tablerect,x_count,y_count)\n",
    "    plt.gcf().set_size_inches(40.0,40.0)\n",
    "    plt.subplot(2,2,1),plt.imshow(h_erode_img,'gray')\n",
    "    plt.subplot(2,2,2),plt.imshow(h_dilate_img,'gray')\n",
    "    plt.subplot(2,2,3),plt.imshow(emptyImagev,'gray')\n",
    "    plt.subplot(2,2,4),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "rows,colums=getGridabc(tablerect,x_segmentation,y_segmentation)\n",
    "print(len(rows),len(colums))\n",
    "if debug:\n",
    "    print(x_segmentation)\n",
    "    print(y_segmentation)\n",
    "    white = (255, 255, 255)\n",
    "    black = (0, 0, 0)\n",
    "    h,w=tablerect.shape\n",
    "    emptyImage1 = tablerect.copy()\n",
    "    for x in colums:\n",
    "        cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "    for y in rows:\n",
    "\n",
    "        cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.imshow(emptyImage1,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"    获取上下线的y坐标\")\n",
    "\n",
    "edges = cv2.Canny(rotate_image,50,150,apertureSize = 3)\n",
    "minLineLength=600\n",
    "scale = 10\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "text_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "text_structureH = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1)) \n",
    "text_structureV = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (5, 5))\n",
    "h_dilate_imgT = cv2.dilate(edges, text_structure, 1)\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, text_structureH, 1)\n",
    "h_dilate_img = cv2.dilate(binary, text_structureH, 1)\n",
    "lines = cv2.HoughLinesP(image=h_erode_img,rho=0.02,theta=np.pi/500, threshold=400,minLineLength=minLineLength,maxLineGap=180)\n",
    "empytImg = np.zeros(h_erode_img.shape, np.uint8)\n",
    "for line in lines: \n",
    "    #print(line)\n",
    "    x1,y1,x2,y2=line[0]\n",
    "    cv2.line(empytImg,(x1,y1),(x2,y2),(255,255,255),1)\n",
    "    \n",
    "#h_erode_img = cv2.erode(edges, h_structure, 1)\n",
    "#h_dilate_img = cv2.dilate(h_erode_img, h_structure, 1)\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(h_erode_img,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(empytImg,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from BaiduAipOcr import BaiduAipOcr\n",
    "\n",
    "print('6：根据行列坐标转化每块到cell') \n",
    "\n",
    "\n",
    "\n",
    "#print(len(tablelist))\n",
    "#print(len(tablelist[0]))\n",
    "savename,extension = os.path.splitext(filename)\n",
    "tablelist = imgtotable(tablerect,rows,colums)\n",
    "df=pd.DataFrame(tablelist)\n",
    "tempoutpath=os.path.join(path,tempout)\n",
    "if not os.path.exists(tempoutpath):\n",
    "    os.makedirs(tempoutpath)\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "writer = pd.ExcelWriter(savepath)\n",
    "df.to_excel(writer, sheet_name=savename)\n",
    "writer.save()\n",
    "writer.close()\n",
    "print(\"ok\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/abctest/'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        sheet_data = ocrimgtoexcel(file,fpath,debug=False)\n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "        sheet_data.to_excel(writer, sheet_name=fname)\n",
    "        writer.save()\n",
    "    writer.close()   "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
