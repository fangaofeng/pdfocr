{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import os\n",
    "try:\n",
    "    import Image\n",
    "except ImportError:\n",
    "    from PIL import Image\n",
    "import cv2\n",
    "import numpy as np\n",
    "import pytesseract\n",
    "from matplotlib import pyplot as plt\n",
    "import math\n",
    "from math import radians, degrees\n",
    "from pdftabextract import imgproc\n",
    "from pdftabextract.common import ROTATION, SKEW_X, SKEW_Y, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL\n",
    "from tabledetect import detectTable, cutImage,roiToCell\n",
    "import pandas as pd\n",
    "import json\n",
    "from BaiduAipOcr import BaiduAipOcr\n",
    "tempout = \"temp/\"\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "def imgtotable(img,rows,colums,debug=False):\n",
    "    ocrclient = BaiduAipOcr()\n",
    "    tablelist = [[\"\" for col in range(0,len(colums))] for row in range(0,len(rows))]\n",
    "    #print(tablelist)\n",
    "    for row, y in enumerate(rows):\n",
    "        print(\"行{}：\".format(row),end=\" \")\n",
    "        for colum,x in enumerate(colums):\n",
    "            if row == 0:\n",
    "                y1=0\n",
    "            else:\n",
    "                y1=rows[row-1]\n",
    "            if colum == 0:\n",
    "                x1=0\n",
    "            else:\n",
    "                x1=colums[colum-1]\n",
    "            x2=x\n",
    "            y2=y\n",
    "            roiimg = img[y1:y2,\n",
    "                  x1:x2]\n",
    "\n",
    "            if debug:\n",
    "                \n",
    "                cv2.imwrite(\"testimage/{}{}.jpg\".format(row,colum),roiimg)\n",
    "\n",
    "            try:\n",
    "                print(\"列{}：\".format(colum),end=\" \")\n",
    "                if debug:\n",
    "                    text=\"err\"\n",
    "                else:\n",
    "                    text = ocrclient.image_to_string(roiimg)\n",
    "            except Exception as e:\n",
    "                print(e)\n",
    "                print(\"RECT:[{}:{},{}:{}]\".format(\n",
    "                    y1, y2, x1, x2))\n",
    "                text = \"error\"\n",
    "            #print(row,colum)\n",
    "            tablelist[row][colum] = text\n",
    "        print(\"\")\n",
    "    return tablelist\n",
    "def ocrimgtoexcel(filename,path,debug=False ):\n",
    "    print('1：读取文件{}'.format(filename))\n",
    "    filepath=os.path.join(path,filename)\n",
    "    iproc_obj = imgproc.ImageProc(filepath)\n",
    "    print('图像h={} w={}'.format(iproc_obj.input_img.shape[0],iproc_obj.input_img.shape[1]))\n",
    "    print('2：去除红色印章')\n",
    "    img,imgredmask = iproc_obj.removeRedStamp(debug=debug)\n",
    "   \n",
    "    if debug:\n",
    "        # display original image and skin image\n",
    "        plt.gcf().set_size_inches(90,50)\n",
    "        plt.subplot(1,2,1), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title('Original Image'), plt.xticks([]), plt.yticks([])\n",
    "        plt.subplot(1,2,2), plt.imshow(cv2.cvtColor(imgredmask, cv2.COLOR_BGR2RGB)), plt.title('HSV Skin Image'), plt.xticks([]), plt.yticks([])\n",
    "        plt.show()\n",
    "    print('3：检测水平线和角度')\n",
    "    sum = 0.0\n",
    "    number = 0\n",
    "    lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                         hough_rho_res=1,\n",
    "                                         hough_theta_res=np.pi/600,\n",
    "                                         hough_votes_thresh=500)\n",
    "\n",
    "\n",
    "    img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "    theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=5)\n",
    "    angle = degrees(theta_rotate[1])\n",
    "    print(\"-----方向{} 校正角度 {}\".format(theta_rotate[0],angle))\n",
    "    #theta_rotateV = iproc_obj.find_rotation_or_skew(only_direction=DIRECTION_VERTICAL)\n",
    "    #print(\"-----垂直校正角度 {}\".format(theta_rotate))\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(img_lines,\"gray\")\n",
    "        plt.show()\n",
    "    print('3：水平校正')\n",
    "    rotate_image = iproc_obj.rotate_image2(iproc_obj.gray_img,angle=angle)\n",
    "    print(rotate_image.shape)\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(30,50)\n",
    "        plt.imshow(rotate_image,'gray')\n",
    "        plt.show()\n",
    "    \n",
    "    print('4：检测表格上下横线')\n",
    "    dt = detectTable(rotate_image)\n",
    "    #ret, thresh_img = cv2.threshold(\n",
    "    #                ~rotate_image, 100, 255, cv2.THRESH_BINARY_INV)\n",
    "    thresh_img = cv2.adaptiveThreshold(\n",
    "        ~rotate_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 25, -2)\n",
    "    h_img = thresh_img.copy()\n",
    "    scale = 8\n",
    "    h_size = int(h_img.shape[1]/scale)\n",
    "\n",
    "    h_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "    dashed_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (3, 1)) \n",
    "    h_structure2 = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (h_size, 3)) # 形态学因子\n",
    "    h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1) # 虚线转为实线\n",
    "    h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1) #腐蚀掉非水平的对象\n",
    "    h_dilate_img = cv2.dilate(h_erode_img, h_structure2, 1)\n",
    "\n",
    "\n",
    "\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(90,50)\n",
    "        plt.subplot(2,1,1),plt.imshow(thresh_img,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(h_dilate_img,'gray')\n",
    "        plt.show()\n",
    "        \n",
    "    \n",
    "    print('5：计算表格上下线坐标')\n",
    "\n",
    "    y_count,y_segmentation = dt.horizontalShadowSplite(h_erode_img,300)\n",
    "    print(len(y_segmentation))\n",
    "    if debug:\n",
    "        emptyImageh=dt.getShadowimg(h_erode_img,y_count)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "        plt.show()\n",
    "        \n",
    "\n",
    "    rows=dt.getLineCor(rotate_image.shape[0],y_segmentation)\n",
    "    x1= 0\n",
    "    y1= rows[0]\n",
    "    x2= rotate_image.shape[1]-1\n",
    "    y2= rows[-1]\n",
    "    print(y_segmentation)\n",
    "    print(rows)\n",
    "    print(\"共{}\".format(len(rows)))\n",
    "    tablerect = rotate_image[y1+5:y2, x1+5:x2-5]\n",
    "    mask = h_dilate_img[y1+5:y2, x1+5:x2-5]\n",
    "    if debug:\n",
    "\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(mask,'gray')\n",
    "        plt.show()\n",
    "          \n",
    "    print('6：图像高斯过滤')\n",
    "    dt = detectTable(tablerect)\n",
    "    # 图像去燥和清晰\n",
    "    H_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (1, 7))  # 形态学因子\n",
    "    dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "    maskT = cv2.erode(mask, dashed_structure, 1)\n",
    "    maskT = cv2.dilate(maskT, H_structure, 1)\n",
    "    tableImgNoborder = cv2.add(maskT,tablerect) # 去掉边界\n",
    "    \n",
    "    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n",
    "    cl1 = clahe.apply(tableImgNoborder)\n",
    "    sigma = 1; threshold = 3; amount = 1\n",
    "    blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "\n",
    "    lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "    sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "    tableImgClear=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "\n",
    "    if debug:\n",
    "        plt.gcf().set_size_inches(40.0,40.0)\n",
    "        plt.subplot(2,1,1),plt.imshow(maskT,'gray')\n",
    "        #plt.subplot(3,1,2),plt.imshow(blurred,'gray')\n",
    "        plt.subplot(2,1,2),plt.imshow(tableImgClear,'gray')\n",
    "        plt.show()\n",
    "\n",
    "\n",
    "\n",
    "   \n",
    "    print('7：计算行和列分割线')\n",
    "    dt = detectTable(tableImgClear)\n",
    "    ret, thresh_img = cv2.threshold(\n",
    "        tableImgClear, 200, 255, cv2.THRESH_BINARY_INV)\n",
    "\n",
    "    #thresh_img = cv2.adaptiveThreshold(\n",
    "    #    ~tableImgClear, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "    H_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (3, 210))\n",
    "    erode_structure = cv2.getStructuringElement(\n",
    "        cv2.MORPH_RECT, (3, 3))# 形态学因子\n",
    "\n",
    "    h_dilate_imgT = cv2.erode(thresh_img, erode_structure, 1)\n",
    "    #h_dilate_imgT = cv2.dilate(h_dilate_imgT, erode_structure, 1)\n",
    "    h_dilate_img = cv2.dilate(h_dilate_imgT, erode_structure, 1)\n",
    "    h_dilate_img = cv2.dilate(h_dilate_img, H_structure, 1)\n",
    "\n",
    "    h_threshold = int(tableImgClear.shape[0]/5)\n",
    "    v_threshold = int(tableImgClear.shape[1]/4)\n",
    "    x_count,x_segmentation = dt.verticalShadowSplite(h_dilate_img,h_threshold,150)\n",
    "    y_count,y_segmentation = dt.horizontalShadowSplite(maskT,v_threshold)\n",
    "\n",
    "    print(len(x_segmentation))\n",
    "    print(len(y_segmentation))\n",
    "    if debug:\n",
    "        #emptyImagev = cv2.dilate(emptyImagev, erode_structure, 1)\n",
    "        emptyImagev=dt.getShadowimg(tableImgClear,x_count,'V')\n",
    "        emptyImageh=dt.getShadowimg(tableImgClear,y_count,'H')\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.subplot(3,1,1),plt.imshow(emptyImagev,'gray')\n",
    "        plt.subplot(3,1,2),plt.imshow(thresh_img,'gray')\n",
    "        plt.subplot(3,1,3),plt.imshow(h_dilate_img,'gray')\n",
    "\n",
    "        plt.show()\n",
    "    print('--分割图片')\n",
    "    rows=dt.getLineCor(tableImgClear.shape[0],y_segmentation)\n",
    "    rows.append(tableImgClear.shape[0]-1)\n",
    "    colums=dt.getLineCor(tableImgClear.shape[1],x_segmentation,next=True)\n",
    "    colums.append(tableImgClear.shape[1]-1)\n",
    "    print(len(rows),len(colums))\n",
    "    savename,extension = os.path.splitext(filename)\n",
    "    tempoutpath=os.path.join(path,tempout)\n",
    "    if debug:\n",
    "        print(x_segmentation)\n",
    "        print(y_segmentation)\n",
    "        white = (255, 255, 255)\n",
    "        black = (0, 0, 0)\n",
    "        h,w=tableImgClear.shape\n",
    "        emptyImage1 = tableImgClear.copy()\n",
    "        for x in colums:\n",
    "            cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "        for y in rows:\n",
    "\n",
    "            cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "        savejpg = os.path.join(tempoutpath,savename+'.jpg')   \n",
    "        cv2.imwrite(savejpg,blurred)\n",
    "        plt.gcf().set_size_inches(60.0,40.0)\n",
    "        plt.imshow(emptyImage1,'gray')\n",
    "        plt.show()\n",
    "    # 临时文件保存名    \n",
    "\n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')      \n",
    "    print('8：每个cell进行识别的tablelist') \n",
    "    \n",
    "    tablelist = imgtotable(tableImgNoborder,rows,colums,debug)\n",
    "    print('9：保存文件')       \n",
    "    \n",
    "    \n",
    "    df=pd.DataFrame(tablelist)\n",
    "    \n",
    "    if not os.path.exists(tempoutpath):\n",
    "        os.makedirs(tempoutpath)\n",
    "    savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "    writer = pd.ExcelWriter(savepath)\n",
    "    df.to_excel(writer, sheet_name=savename)\n",
    "    writer.save()\n",
    "    writer.close()\n",
    "    print('10：{}.jpg '.format(savename))\n",
    "    \n",
    "    return df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "path = 'j:/fgf/'\n",
    "filename=\"1.jpg\"\n",
    "filepath=os.path.join(path,filename)\n",
    "ocrimgtoexcel(filename,path,debug=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/fgf/'\n",
    "print(\"处理 {} 目录下图片\".format(fpathe))\n",
    "writer = pd.ExcelWriter(os.path.join(fpathe,'allpages.xlsx'))\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.jpg':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        \n",
    "        sheet_data = ocrimgtoexcel(file,fpath,debug=False)\n",
    "\n",
    "            \n",
    "        print(\"----{} is complete--- \".format(file))\n",
    "        sheet_data.to_excel(writer, sheet_name=fname)\n",
    "    writer.save()\n",
    "    writer.close()                        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def formatnumber(t):\n",
    "    if not isinstance(t,str) :\n",
    "        return  t\n",
    "    t= t.replace('.','')\n",
    "    t= t.replace(',','')\n",
    "    t= t.replace('，','')\n",
    "    t= t.replace('、','')\n",
    "\n",
    "    if(len(t)>2):\n",
    "        tt =''.join([t[:-2],'.',t[-2:]])\n",
    "    elif len(t) >=1:\n",
    "        \n",
    "        tt =''.join([t,'.00'])\n",
    "    else:\n",
    "        tt = t\n",
    "    return tt\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "fpathe = 'j:/1155cmbc/temp'\n",
    "print(\"处理 {} excel\".format(fpathe))\n",
    "\n",
    "for fpath,dirs,fs in os.walk(fpathe):\n",
    "    \n",
    "    for file in fs:\n",
    "        fname,extension = os.path.splitext(file)\n",
    "        \n",
    "        if extension != '.xlsx':\n",
    "            continue\n",
    "        print(\"---- {} is start---\".format(file))\n",
    "        filepath = os.path.join(fpathe,file)\n",
    "        dframe = pd.read_excel(filepath, sheet_name=fname)\n",
    "        for index,rows in dframe.iterrows():\n",
    "            if index == 0:\n",
    "                continue\n",
    "            dframe.iloc[index,3] = formatnumber(rows[3])\n",
    "\n",
    "            dframe.iloc[index,4] = formatnumber(rows[4])\n",
    "            dframe.iloc[index,5] = formatnumber(rows[5])\n",
    "\n",
    "        dframe.to_excel(os.path.join(fpathe,fname+'t'+extension))\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fpathe = 'j:/1155cmbc/temp/'\n",
    "fs=\"1155cmb_页面_07.xlsx\"\n",
    "filepath = os.path.join(fpathe,fs)\n",
    "print(filepath)\n",
    "fname,extension = os.path.splitext(fs)\n",
    "dframe = pd.read_excel(filepath, sheet_name=fname)\n",
    "for index,rows in dframe.iterrows():\n",
    "    if index == 0:\n",
    "        continue\n",
    "\n",
    "    dframe.iloc[index,3] = formatnumber(rows[3])\n",
    "\n",
    "    dframe.iloc[index,4] = formatnumber(rows[4])\n",
    "    dframe.iloc[index,5] = formatnumber(rows[5])\n",
    "\n",
    "print(os.path.join(fpathe,fname+'t.xlsx'))\n",
    "dframe.to_excel(os.path.join(fpathe,fname+'t.xlsx'))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "debug=True\n",
    "path = 'j:/1155cmbc/'\n",
    "filename=\"6.jpg\"\n",
    "print('1：读取文件{}'.format(filename))\n",
    "filepath=os.path.join(path,filename)\n",
    "iproc_obj = imgproc.ImageProc(filepath)\n",
    "print('图像h={} w={}'.format(iproc_obj.input_img.shape[0],iproc_obj.input_img.shape[1]))\n",
    "print('2：去除红色印章')\n",
    "img,imgredmask = iproc_obj.removeRedStamp(debug=debug)\n",
    "\n",
    "if debug:\n",
    "    # display original image and skin image\n",
    "    plt.gcf().set_size_inches(90,50)\n",
    "    plt.subplot(1,2,1), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title('Original Image'), plt.xticks([]), plt.yticks([])\n",
    "    plt.subplot(1,2,2), plt.imshow(cv2.cvtColor(imgredmask, cv2.COLOR_BGR2RGB)), plt.title('HSV Skin Image'), plt.xticks([]), plt.yticks([])\n",
    "    plt.show()\n",
    "print('3：检测水平线和角度')\n",
    "sum = 0.0\n",
    "number = 0\n",
    "lines_hough = iproc_obj.detect_lines(canny_low_thresh=50, canny_high_thresh=250, canny_kernel_size=3,\n",
    "                                     hough_rho_res=1,\n",
    "                                     hough_theta_res=np.pi/600,\n",
    "                                     hough_votes_thresh=500)\n",
    "\n",
    "\n",
    "img_lines = iproc_obj.draw_lines(orig_img_as_background=True)\n",
    "theta_rotate = iproc_obj.find_rotation_or_skewold(rot_thresh=0.001, rot_same_dir_thresh=0.1, omit_on_rot_thresh=5)\n",
    "angle = degrees(theta_rotate[1])\n",
    "print(\"-----方向{} 校正角度 {}\".format(theta_rotate[0],angle))\n",
    "#theta_rotateV = iproc_obj.find_rotation_or_skew(only_direction=DIRECTION_VERTICAL)\n",
    "#print(\"-----垂直校正角度 {}\".format(theta_rotate))\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(img_lines,\"gray\")\n",
    "    plt.show()\n",
    "print('3：水平校正')\n",
    "rotate_image = iproc_obj.rotate_image2(iproc_obj.gray_img,angle=angle)\n",
    "print(rotate_image.shape)\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(30,50)\n",
    "    plt.imshow(rotate_image,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('4：检测表格上下横线')\n",
    "dt = detectTable(rotate_image)\n",
    "#ret, thresh_img = cv2.threshold(\n",
    "#                ~rotate_image, 100, 255, cv2.THRESH_BINARY_INV)\n",
    "thresh_img = cv2.adaptiveThreshold(\n",
    "    ~rotate_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 25, -2)\n",
    "h_img = thresh_img.copy()\n",
    "scale = 8\n",
    "h_size = int(h_img.shape[1]/scale)\n",
    "\n",
    "h_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 1))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 1)) \n",
    "h_structure2 = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (h_size, 3)) # 形态学因子\n",
    "h_dilate_imgT = cv2.dilate(h_img, dashed_structure, 1) # 虚线转为实线\n",
    "h_erode_img = cv2.erode(h_dilate_imgT, h_structure, 1) #腐蚀掉非水平的对象\n",
    "h_dilate_img = cv2.dilate(h_erode_img, h_structure2, 1)\n",
    "\n",
    "\n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(90,50)\n",
    "    plt.subplot(2,1,1),plt.imshow(thresh_img,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(h_dilate_img,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('5：计算表格上下线坐标')\n",
    "\n",
    "y_count,y_segmentation = dt.horizontalShadowSplite(h_erode_img,400)\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    emptyImageh=dt.getShadowimg(h_erode_img,y_count)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(emptyImageh,'gray')\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rows=dt.getLineCor(rotate_image.shape[0],y_segmentation)\n",
    "x1= 0\n",
    "y1= rows[0]\n",
    "x2= rotate_image.shape[1]-1\n",
    "y2= rows[-1]\n",
    "print(y_segmentation)\n",
    "print(rows)\n",
    "print(\"共{}\".format(len(rows)))\n",
    "tablerect = rotate_image[y1+5:y2, x1+5:x2-5]\n",
    "mask = h_dilate_img[y1+5:y2, x1+5:x2-5]\n",
    "if debug:\n",
    "\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(2,1,1),plt.imshow(tablerect,'gray')\n",
    "    plt.subplot(2,1,2),plt.imshow(mask,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('6：图像高斯过滤')\n",
    "dt = detectTable(tablerect)\n",
    "# 图像去燥和清晰\n",
    "H_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (1, 7))  # 形态学因子\n",
    "dashed_structure = cv2.getStructuringElement(\n",
    "cv2.MORPH_RECT, (7, 3))  # 形态学因子\n",
    "maskT = cv2.erode(mask, dashed_structure, 1)\n",
    "maskT = cv2.dilate(maskT, H_structure, 1)\n",
    "tableImgNoborder = cv2.add(maskT,tablerect) # 去掉边界\n",
    "\n",
    "clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n",
    "cl1 = clahe.apply(tableImgNoborder)\n",
    "sigma = 1; threshold = 3; amount = 1\n",
    "blurred=cv2.GaussianBlur(cl1,(0,0),1,None,1)\n",
    "\n",
    "lowContrastMask = abs(cl1 - blurred) < threshold\n",
    "sharpened = blurred*(1+amount) + blurred*(-amount)\n",
    "tableImgClear=cv2.bitwise_or(sharpened.astype(np.uint8),lowContrastMask.astype(np.uint8))\n",
    "\n",
    "if debug:\n",
    "    plt.gcf().set_size_inches(40.0,40.0)\n",
    "    plt.subplot(3,1,1),plt.imshow(maskT,'gray')\n",
    "    plt.subplot(3,1,2),plt.imshow(blurred,'gray')\n",
    "    plt.subplot(3,1,3),plt.imshow(tableImgClear,'gray')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print('7：计算行和列分割线')\n",
    "dt = detectTable(tableImgClear)\n",
    "ret, thresh_img = cv2.threshold(\n",
    "    tableImgClear, 200, 255, cv2.THRESH_BINARY_INV)\n",
    "\n",
    "#thresh_img = cv2.adaptiveThreshold(\n",
    "#    ~tableImgClear, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, -2)\n",
    "H_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 210))\n",
    "erode_structure = cv2.getStructuringElement(\n",
    "    cv2.MORPH_RECT, (3, 3))# 形态学因子\n",
    "\n",
    "h_dilate_imgT = cv2.erode(thresh_img, erode_structure, 1)\n",
    "#h_dilate_imgT = cv2.dilate(h_dilate_imgT, erode_structure, 1)\n",
    "h_dilate_img = cv2.dilate(h_dilate_imgT, erode_structure, 1)\n",
    "h_dilate_img = cv2.dilate(h_dilate_img, H_structure, 1)\n",
    "\n",
    "h_threshold = int(tableImgClear.shape[0]/5)\n",
    "v_threshold = int(tableImgClear.shape[1]/4)\n",
    "x_count,x_segmentation = dt.verticalShadowSplite(h_dilate_img,h_threshold,150)\n",
    "y_count,y_segmentation = dt.horizontalShadowSplite(maskT,v_threshold)\n",
    "\n",
    "print(len(x_segmentation))\n",
    "print(len(y_segmentation))\n",
    "if debug:\n",
    "    #emptyImagev = cv2.dilate(emptyImagev, erode_structure, 1)\n",
    "    emptyImagev=dt.getShadowimg(tableImgClear,x_count,'V')\n",
    "    emptyImageh=dt.getShadowimg(tableImgClear,y_count,'H')\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.subplot(3,1,1),plt.imshow(emptyImagev,'gray')\n",
    "    plt.subplot(3,1,2),plt.imshow(thresh_img,'gray')\n",
    "    plt.subplot(3,1,3),plt.imshow(h_dilate_img,'gray')\n",
    "\n",
    "    plt.show()\n",
    "    \n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "   \n",
    "print('--分割图片')\n",
    "rows=dt.getLineCor(tableImgClear.shape[0],y_segmentation)\n",
    "rows.append(tableImgClear.shape[0]-1)\n",
    "colums=dt.getLineCor(tableImgClear.shape[1],x_segmentation,next=True)\n",
    "colums.append(tableImgClear.shape[1]-1)\n",
    "print(len(rows),len(colums))\n",
    "if debug:\n",
    "    print(x_segmentation)\n",
    "    print(y_segmentation)\n",
    "    white = (255, 255, 255)\n",
    "    black = (0, 0, 0)\n",
    "    h,w=tableImgClear.shape\n",
    "    emptyImage1 = tableImgClear.copy()\n",
    "    for x in colums:\n",
    "        cv2.line(emptyImage1, (x, 0), (x, h), black)\n",
    "    for y in rows:\n",
    "\n",
    "        cv2.line(emptyImage1, (0, y), (w, y), black)\n",
    "    plt.gcf().set_size_inches(60.0,40.0)\n",
    "    plt.imshow(emptyImage1,'gray')\n",
    "    plt.show()\n",
    "# 临时文件保存名    \n",
    "savename,extension = os.path.splitext(filename)\n",
    "tempoutpath=os.path.join(path,tempout)\n",
    "if not os.path.exists(tempoutpath):\n",
    "    os.makedirs(tempoutpath)\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')      \n",
    "print('8：每个cell进行识别的tablelist') \n",
    "\n",
    "tablelist = imgtotable(blurred,rows,colums,debug)\n",
    "print('9：保存文件')       \n",
    "\n",
    "\n",
    "df=pd.DataFrame(tablelist)\n",
    "\n",
    "if not os.path.exists(tempoutpath):\n",
    "    os.makedirs(tempoutpath)\n",
    "savepath = os.path.join(tempoutpath,savename+'.xlsx')\n",
    "writer = pd.ExcelWriter(savepath)\n",
    "df.to_excel(writer, sheet_name=savename)\n",
    "writer.save()\n",
    "writer.close()\n",
    "print('10：{}.jpg '.format(savename))\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
